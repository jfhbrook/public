#!/usr/bin/env bash

set -euo pipefail

# Logging

function log-debug {
  if [ -n "${DEBUG:-}" ]; then
    echo 'debug:' "$@"
  fi
}

function log-info {
  echo 'info:' "$@"
}

function log-warn {
  echo 'warn:' "$@"
}

function log-error {
  echo 'error:' "$@"
}

function log-fatal {
  echo 'fatal:' "$@"
}

HELP_MAIN='coprctl uses copr-cli and yq to manage COPR resources using yaml, like Kubernetes.

 Find more information at: https://github.com/jfhbrook/public/tree/main/coprctl

Commands:
  get             Display a resource
  apply           Apply a configuration to a resource by file name or stdin

Usage:
  coprctl [flags] [options]

Use "coprctl <command> --help" for more information about a given command.'

function main {
  NAMESPACE="jfhbrook/joshiverse"  # TODO: manage this in a config of contexts
  COMMAND=""
  TYPE=""
  NAME=""

  DRY_RUN="none"
  FILENAME=""

  local show_help=""

  while [[ $# -gt 0 ]]; do
    case ${1} in
      --help)
        show_help=1
        shift
        ;;
      -n|--namespace)
        NAMESPACE="${1}"
        shift
        ;;
      --dry-run)
        if [[ "${2}" =~ ^(none|server|client)$ ]]; then
          DRY_RUN="${2}"
          shift
          shift
        else
          log-fatal "--dry-run must be one of: none, server, client"
          exit 1
        fi
        ;;
      -f|--filename)
        FILENAME="${2}"
        shift
        shift
        ;;
      -*)
        log-fatal "unknown option: ${1}"
        exit 1
        ;;
      *)
        if [ -z "${COMMAND}" ]; then
          COMMAND="${1}"
          shift
        elif [ -z "${TYPE}" ]; then
          TYPE="${1}"
          shift
        elif [ -z "${NAME}" ] && [[ "${COMMAND}" == 'get' ]]; then
          NAME="${1}"
          shift
        else
          log-fatal "unknown argument: ${1}"
          exit 1
        fi
        ;;
    esac
  done

  log-debug "command: ${COMMAND:-NULL}"
  log-debug "type: ${TYPE:-NULL}"

  case "${COMMAND}" in
    get)
      if [ -n "${show_help}" ]; then
        echo "${HELP_GET}"
        exit
      fi
      get
      ;;
    apply)
      if [ -n "${show_help}" ]; then
        echo "${HELP_APPLY}"
        exit
      fi

      apply
      ;;
    api-resources)
      if [ -n "${show_help}" ]; then
        echo "${HELP_API_RESOURCES}"
        exit
      fi
      api-resources
      ;;
    *)
      if [ -n "${COMMAND}" ]; then
        log-error "unknown command: ${COMMAND}"
      fi
      echo "${HELP_MAIN}"
      exit
      ;;
  esac
}

# Get command

HELP_GET='Display a resource.

Prints a yaml representation of the selected resource, intended for easy insertion into a resources file. Currently very limited, but may be expanded to offer more kubectl-like capabilities in the future.

Use "coprctl api-resources" for a complete list of supported resources.

Examples:
  # Show a pypi package called "python3-pyee"
  coprctl get package-pypi python3-pyee

Usage:
  coprctl get TYPE NAME [flags] [options]'

function get {
  local base='{"apiVersion": "coprctl/v1alpha1"}'
  local res
  local type
  local name

  case "${TYPE}" in
    project)
      # NOTE: Projects don't return an easily parseable format and most of the
      # properties are missing, womp womp
      log-fatal "not implemented: project"
      log-info '(try "copr-cli get '"'${NAME}'"')'
      exit 1
      ;;
    chroot)
      # TODO: This shows a yaml representation - great! - but I haven't
      # implemented the apply half of this, and I'd expect the format to change
      # significantly
      res="$(copr-cli get-chroot "${NAMESPACE}/${NAME}" | yq .)"

      res="${res}" name="${NAME}" yq '.kind = "chroot" | .meta.name = env(name) | .spec = env(res) | del(.spec.name)' -P <<< "${base}"
      ;;
    package-*)
      res="$(copr-cli get-package "${NAMESPACE}" --name "${NAME}" | yq .)"

      type="package-$(yq '.source_type' <<< "${res}")"
      name="$(yq '.name' <<< "${res}")"

      if [[ "${type}" != "${TYPE}" ]]; then
        log-fatal "unexpected type: ${type} (expected: ${TYPE})"
        exit 1
      fi

      res="${res}" kind="${type}" name="${name}" yq '.kind = env(kind) | .meta.name = env(name) | .spec = env(res) | del(.spec.name)' -P <<< "${base}"
      ;;
    permissions)
      log-fatal "not implemented: permissions"
      exit 1
      ;;
    *)
      log-fatal "unknown type: ${TYPE}"
      exit 1
      ;;
  esac
}

# Apply command

HELP_APPLY='Apply a configuration to a resource by file name or stdin. The resource name must be specified. This resource will be created if it doesn'"'"'t exist yet. To use '"'"'apply'"'"', always create the resource initially with either '"'"'apply'"'"' or '"'"'create --save-config'"'"'.

 Formats understood by yq are accepted.

Examples:
  # Apply the configuration in copr.yaml
  coprctl apply -f ./copr.json
  
Options:
    --namespace:
  Set the namespace for the COPR, of the format (username|organization)/project.
    --dry-run='"'"'none'"'"':
	Must be "none", "server", or "client". If client strategy, only print the object that would be sent, without sending it. If server strategy, submit server-side request without persisting the resource.

    -f, --filename=[]:
	The file that contains the configurations to apply.

Usage:
  coprctl apply (-f FILENAME) [options]

Use "coprctl <command> --help" for more information about a given command.'

function apply {
  # TODO: This won't clean up the tmpfile on exit. It's not a huge deal - the
  # OS should clean it up on boots - but it's *improper*.
  if [ -z "${FILENAME}" ]; then
    FILENAME="$(mktemp)"
    "${FILENAME}" < /dev/stdin
  fi

  # file, doc selector and argv set globally to avoid DI Hell. Luckily this
  # is the only call site we have to be careful about.
  yq --no-doc 'document_index' "${FILENAME}" | while read -r i; do
    DOC='select(document_index == '"${i}"')'
    ARGV=()

    log-debug 'doc:' "${DOC}"

    load-document

    if [[ "${DRY_RUN}" != 'none' ]]; then
      log-info 'dry-run:' copr-cli "${ARGV[@]}"
    else
      copr-cli "${ARGV[@]}"
    fi
  done
}

function load-document {
  local kind
  local apiVersion

  kind="$(yq "${DOC}"' | .kind' "./${FILENAME}")"

  log-debug "kind: ${kind}"
  apiVersion="$(yq "${DOC}"' | .apiVersion' "./${FILENAME}")"

  # because we're classy like that
  if [[ "${apiVersion}" != 'coprctl/v1alpha1' ]]; then
    log-fatal "Unknown apiVersion: ${apiVersion}"
    log-info "Supported versions are: coprctl/v1aplha1"
    exit 1
  fi

  case "${kind}" in
    project)
      load-project
      ;;
    chroot)
      # TODO: Chroots have an odd mechanic around "comps", which involve .xml
      # files. Implement this when I actually need it.
      log-fatal "not implemented: chroot"
      exit 1
      ;;
    package-pypi)
      load-package pypi
      load-array-property '.spec.pythonversions' pythonversions
      load-property '.spec.packageversion' packageversion
      load-property '.spec.spec-generator' spec-generator
      load-property '.spec.template' template
      ;;
    package-scm)
      load-package scm

      log-fatal 'not implemented: package-scm'
      exit 1
      ;;
    package-distgit)
      load-package distgit

      log-fatal 'not implemented: package-distgit'
      exit 1
      ;;
    package-rubygems)
      load-package rubygems
      load-property '.spec.gem' gem
      ;;
    package-custom)
      load-package custom

      log-fatal 'not implemented: package-custom'
      exit 1
      ;;
    permissions)
      log-fatal "not implemented: permissions"
      exit 1
      ;;
    *)
      log-fatal "unknown kind: ${kind}"
      exit 1
      ;;
  esac
}


function load-property {
  local selector="${1}"
  local name="${2}"

  local value

  value="$(yq "${DOC}"' | '"${selector}" "${FILENAME}")"

  # TODO: Ideally I'd get yq to return a blank instead of the string "null".
  # Unfortunately, alternatives and doc filtering combined can have strange
  # results.
  if [[ "${value}" != 'null' ]]; then
    ARGV+=("--${name}" "${value}")
  fi
}

function load-array-property {
  local selector="${1}"
  local name="${2}"

  ARGV+=("--${name}")

  for value in $(yq "${DOC}"' | '"${selector}"' | .[]' "${FILENAME}"); do
    ARGV+=("${value}")
  done
}

function load-project {
  local name
  local action="modify"

  name="$(yq "${DOC}"' | .metadata.name' "${FILENAME}")"

  if [[ "${DRY_RUN}" == 'client' ]]; then
    log-info 'dry-run:' copr-cli get "${name}"
    action="create"
  else
    log-debug "checking if project ${name} exists"
    if ! copr-cli get "${name}" &> /dev/null; then
      log-debug "project ${name} does not exist"
      action="create"
    fi
  fi

  ARGV+=("${action}" "${name}")

  load-property '.spec.chroot' chroot
  load-property '.spec.description' description
  load-property '.spec.instructions' instructions
  load-property '.spec.disable_createrepo' disable_createrepo
  load-property '.spec.enable-net' enable-net
  load-property '.spec.unlisted-on-hp' unlisted-on-hp
  load-property '.spec.auto-prune' auto-prune
  load-property '.spec.isolation' isolation
  load-property '.spec.bootstrap' bootstrap
  load-property '.spec.delete-after-days' delete-after-days 
  load-property '.spec.module-hotfixes' module-hotfixes
  load-property '.spec.multilib' multilib
  load-property '.spec.fedora-review' fedora-review
  load-property '.spec.appstream' appstream
  load-property '.spec.follow-fedora-branching' follow-fedora-branching
  load-property '.spec.repo' repo
  load-property '.spec.runtime-repo-dependency' runtime-repo-dependency
  load-property '.spec.packit-forge-project-allowed' packit-forge-project-allowed
}

function load-package {
  local type="${1}"

  local copr
  local name
  local action

  # TODO: should this property be on metadata?
  copr="$(yq "${DOC}"' | .spec.copr' "${FILENAME}")"
  name="$(yq "${DOC}"' | .metadata.name' "${FILENAME}")"

  action="edit-package-${type}"


  if [[ "${DRY_RUN}" == 'client' ]]; then
    log-info 'dry-run:' copr-cli get-package "${copr}" --name "${name}"
    action="add-package-${type}"
  else
    log-debug "checking if package ${copr} --name ${name} exists"
    if ! copr get-package "${copr}" --name "${name}" &> /dev/null; then
      log-debug "package ${copr} --name ${name} does not exist"
      action="add-package-${type}"
    fi
  fi

  ARGV+=("${action}" "${copr}" --name "${name}")

  load-property '.spec.webhook-rebuild' webhook-rebuild
  load-property '.spec.max-builds' max-builds
}

HELP_API_RESOURCES='Print supported API resources.

Examples:
  # Print supported API resources
  coprctl api-resources
  
Usage:
  coprctl api-resources'

function api-resources {
  echo "NAME
project
package-pypi
package-scm
package-distgit
package-rubygems
package-custom"
}

# giddyup
main "$@"
